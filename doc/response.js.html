<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.3.2">
  <meta charset="utf-8">
  <title>Source: response.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: response.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/**
 * Response handler for dealing with the parsing of responses from
 * Barista (enveloping Minerva).
 *
 * It will detect if the incoming response is structured correctly and
 * give safe access to fields and properties.
 * 
 * It is not meant to be a model for the parts in the data section,
 * see the graph sections for that.
 * 
 * @module bbop-response-barista
 */

var bbop = require(&#x27;bbop-core&#x27;);
var us = require(&#x27;underscore&#x27;);
var bbop_rest_response = require(&#x27;bbop-rest-response&#x27;).base;

/**
 * Contructor for a Minerva REST JSON response object.
 * 
 * The constructor argument is an object or a string.
 * 
 * @constructor
 * @param {Object|String} raw - the JSON object as a string or object
 * @returns {response} response object
 */
var response = function(raw){
    bbop_rest_response.call(this);
    this._is_a = &#x27;bbop-response-barista&#x27;;

    // Required top-level strings in the response.
    // message and message_type are defined in the superclass.
    this._uid = null; // initiating user
    this._packet_id = null; // identify the packet
    this._intention = null; // what the user wanted to do (&#x27;query&#x27;, &#x27;action&#x27;)
    this._signal = null; // &#x27;merge&#x27;, &#x27;rebuild&#x27;, &#x27;meta&#x27;, etc.

    // Optional top-level strings in the response.
    this._commentary = null;

    // Optional top-level objects.
    // Data contains model_id, inconsistency, etc.
    this._data = null;

    // Start with the assumption that the response is bad, try and
    // prove otherwise.
    this.okay(false);

    // Raw will only be provided in that cases that it makes sense.
    this._raw = null;
    
    // If we have no data coming in, there is a problem...
    if( ! raw ){
	
	this.message(&#x27;empty response in handler&#x27;);
	this.message_type(&#x27;error&#x27;);

    }else{

	// If we do have something coming in, And it looks like
	// something we might be able to deal with, do our best to
	// decode it.
	var itsa = bbop.what_is(raw);
	if( itsa !== &#x27;string&#x27; &amp;amp;&amp;amp; itsa !== &#x27;object&#x27; ){
	    
	    // No idea what this thing is...
	    this.message(&#x27;bad argument type in handler&#x27;);
	    this.message_type(&#x27;error&#x27;);

	}else{
	    
	    // Try to make the string an object.
	    if( itsa === &#x27;string&#x27; ){
		try {
		    this._raw = JSON.parse(raw);
		}catch(e){
		    // Didn&#x27;t make it--chuck it to create a signal.
		    this._raw = null;
		    this.message(&#x27;handler could not parse string response&#x27;);
		    this.message_type(&#x27;error&#x27;);
		}
	    }else{
		// Looks like somebody else got here first.
		this._raw = raw;
	    }

	    // If we managed to define some kind of raw incoming data
	    // that is (or has been parsed to) a model, start probing
	    // it out to see if it is structured correctly.
	    if( this._raw ){

		// Check required fields.
		var jresp = this._raw;
		// These must always be defined.
		if( ! jresp[&#x27;message-type&#x27;] || ! jresp[&#x27;message&#x27;] ){
		    // Core info.
		    this.message_type(&#x27;error&#x27;);
		    this.message(&#x27;message and message_type must always exist&#x27;);
		}else{

		    // Take out the individual optional bits for
		    // examination.
		    var cdata = jresp[&#x27;commentary&#x27;] || null;
		    var odata = jresp[&#x27;data&#x27;] || null;

		    // If data, object.
		    if( odata &amp;amp;&amp;amp; bbop.what_is(odata) !== &#x27;object&#x27; ){
		    // if( odata &amp;amp;&amp;amp; bbop.what_is(odata) != &#x27;object&#x27; &amp;amp;&amp;amp;
		    // 	bbop.what_is(odata) != &#x27;array&#x27; ){
			this.message(&#x27;data not object&#x27;);
			this.message_type(&#x27;error&#x27;);
		    }else{
			// If commentary, string.
			if( cdata &amp;amp;&amp;amp; bbop.what_is(cdata) !== &#x27;string&#x27; ){
			    this.message(&#x27;commentary not string&#x27;);
			    this.message_type(&#x27;error&#x27;);
			}else{
			    // Looks fine then I guess.
			    this.okay(true);

			    // Super-class.
			    this.message_type(jresp[&#x27;message-type&#x27;]);
			    this.message(jresp[&#x27;message&#x27;]);

			    // Plug in the other required fields.
			    this._uid = jresp[&#x27;uid&#x27;] || &#x27;unknown&#x27;;
			    this._intention = jresp[&#x27;intention&#x27;] || &#x27;unknown&#x27;;
			    this._signal = jresp[&#x27;signal&#x27;] || &#x27;unknown&#x27;;
			    this._packet_id = jresp[&#x27;packet-id&#x27;] || &#x27;unknown&#x27;;

			    // Add any additional fields.
			    if( cdata ){ this._commentary = cdata; }
			    if( odata ){ this._data = odata; }
			}
		    }
		}
	    }
	}
    }
};
bbop.extend(response, bbop_rest_response);

/**
 * Returns the user id (uid) for a call if it was generated my a known
 * user.
 * 
 * @returns {String|null} string or null
 */
response.prototype.user_id = function(){
    var ret = null;
    if( this._uid ){ ret = this._uid; }
    return ret;
};

/**
 * Returns the user intention for a call.
 * 
 * @returns {String|null} string or null
 */
response.prototype.intention = function(){
    var ret = null;
    if( this._intention ){ ret = this._intention; }
    return ret;
};

/**
 * Returns the server&#x27;s action signal, if there was one.
 * 
 * @returns {String|null} string or null
 */
response.prototype.signal = function(){
    var ret = null;
    if( this._signal ){ ret = this._signal; }
    return ret;
};

/**
 * Returns the response&#x27;s unique id. Usful to make sure you&#x27;re not
 * talking to yourself in some cases.
 * 
 * @returns {String|null} string or null
 */
response.prototype.packet_id = function(){
    var ret = null;
    if( this._packet_id ){ ret = this._packet_id; }
    return ret;
};

/**
 * Returns the commentary object (whatever that might be in any given
 * case).
 * 
 * @returns {Object|null} copy of commentary object or null
 */
response.prototype.commentary = function(){
    var ret = null;
    if( this._commentary ){
	ret = bbop.clone(this._commentary);
    }
    return ret;
};

/**
 * Returns the data object (whatever that might be in any given
 * case). This grossly returns all response data, if any.
 * 
 * @returns {Object|null} copy of data object or null
 */
response.prototype.data = function(){
    var ret = null;
    if( this._data ){
	ret = bbop.clone(this._data);
    }
    return ret;
};

/**
 * Returns the model id of the response.
 * 
 * @returns {String|null} string or null
 */
response.prototype.model_id = function(){
    var ret = null;
    if( this._data &amp;amp;&amp;amp; this._data[&#x27;id&#x27;] ){
	ret = this._data[&#x27;id&#x27;];
    }
    return ret;
};

/**
 * Returns true or false on whether or not the returned model is
 * thought to be inconsistent. Starting assumption is that it is not.
 * 
 * @returns {Boolean} true or false
 */
response.prototype.inconsistent_p = function(){
    var ret = false;
    if( this._data &amp;amp;&amp;amp;
	typeof(this._data[&#x27;inconsistent-p&#x27;]) !== &#x27;undefined&#x27; &amp;amp;&amp;amp;
	this._data[&#x27;inconsistent-p&#x27;] === true ){
	ret = true;
    }
    return ret;
};

/**
 * Returns a true or false depending on the existence an undo list.
 * 
 * @returns {Boolean} boolean
 */
response.prototype.has_undo_p = function(){
    var ret = false;
    if( this._data &amp;amp;&amp;amp; this._data[&#x27;undo&#x27;] &amp;amp;&amp;amp; 
	us.isArray(this._data[&#x27;undo&#x27;]) &amp;amp;&amp;amp;
	this._data[&#x27;undo&#x27;].length &gt; 0 ){
	ret = true;
    }
    return ret;
};

/**
 * Returns a true or false depending on the existence a redo list.
 * 
 * @returns {Boolean} boolean
 */
response.prototype.has_redo_p = function(){
    var ret = false;
    if( this._data &amp;amp;&amp;amp; this._data[&#x27;redo&#x27;] &amp;amp;&amp;amp; 
	us.isArray(this._data[&#x27;redo&#x27;]) &amp;amp;&amp;amp;
	this._data[&#x27;redo&#x27;].length &gt; 0 ){
	ret = true;
    }
    return ret;
};

/**
 * Returns a list of the facts in the response. Empty list if none.
 * 
 * @returns {Array} list
 */
response.prototype.facts = function(){
    var ret = [];
    if( this._data &amp;amp;&amp;amp; this._data[&#x27;facts&#x27;] &amp;amp;&amp;amp; 
	us.isArray(this._data[&#x27;facts&#x27;]) ){
	ret = this._data[&#x27;facts&#x27;];
    }
    return ret;
};

/**
 * Returns a list of the properties in the response. Empty list if none.
 * 
 * @returns {Array} list
 */
response.prototype.properties = function(){
    var ret = [];
    if( this._data &amp;amp;&amp;amp; this._data[&#x27;properties&#x27;] &amp;amp;&amp;amp; 
	us.isArray(this._data[&#x27;properties&#x27;]) ){
	ret = this._data[&#x27;properties&#x27;];
    }
    return ret;
};

/**
 * Returns a list of the individuals in the response. Empty list if none.
 * 
 * @returns {Array} list
 */
response.prototype.individuals = function(){
    var ret = [];
    if( this._data &amp;amp;&amp;amp; this._data[&#x27;individuals&#x27;] &amp;amp;&amp;amp; 
	us.isArray(this._data[&#x27;individuals&#x27;]) ){
	ret = this._data[&#x27;individuals&#x27;];
    }
    return ret;
};

/**
 * Returns a list of the inferred_individuals in the response. Empty
 * list if none.
 * 
 * @returns {Array} list
 */
response.prototype.inferred_individuals = function(){
    var ret = [];
    if( this._data &amp;amp;&amp;amp; this._data[&#x27;individuals-i&#x27;] &amp;amp;&amp;amp; 
	us.isArray(this._data[&#x27;individuals-i&#x27;]) ){
	ret = this._data[&#x27;individuals-i&#x27;];
    }
    return ret;
};

/**
 * Returns a list of the (complex) annotations found in the
 * response. Sometimes not there, so check the return.
 * 
 * @returns {Array} list
 */
response.prototype.annotations = function(){
    var ret = [];
    if( this._data &amp;amp;&amp;amp; this._data[&#x27;annotations&#x27;] &amp;amp;&amp;amp; 
	us.isArray(this._data[&#x27;annotations&#x27;]) ){
	ret = this._data[&#x27;annotations&#x27;];
    }
    return ret;
};

/**
 * Returns the string of the export found in the return.
 * 
 * @returns {String} string
 */
response.prototype.export_model = function(){
    var ret = &#x27;&#x27;;
    if( this._data &amp;amp;&amp;amp; this._data[&#x27;export&#x27;] ){
	ret = this._data[&#x27;export&#x27;];
    }
    return ret;
};

/**
 * Returns a list of the relations found in the response. Sometimes not
 * there, so check the return.
 * 
 * @returns {Array} list
 */
response.prototype.relations = function(){
    var ret = [];
    if( this._data &amp;amp;&amp;amp; this._data[&#x27;meta&#x27;] &amp;amp;&amp;amp; this._data[&#x27;meta&#x27;][&#x27;relations&#x27;] &amp;amp;&amp;amp; 
	us.isArray(this._data[&#x27;meta&#x27;][&#x27;relations&#x27;]) ){
	ret = this._data[&#x27;meta&#x27;][&#x27;relations&#x27;];
    }
    return ret;
};

/**
 * Returns a list of the evidence found in the response. Sometimes not
 * there, so check the return.
 * 
 * @returns {Array} list
 */
response.prototype.evidence = function(){
    var ret = [];
    if( this._data &amp;amp;&amp;amp; this._data[&#x27;meta&#x27;] &amp;amp;&amp;amp; this._data[&#x27;meta&#x27;][&#x27;evidence&#x27;] &amp;amp;&amp;amp; 
	us.isArray(this._data[&#x27;meta&#x27;][&#x27;evidence&#x27;]) ){
	ret = this._data[&#x27;meta&#x27;][&#x27;evidence&#x27;];
    }
    return ret;
};

/**
 * Returns a list the model ids found in the response. Sometimes not
 * there, so check the return.
 * 
 * See Also: &amp;lt;models_meta&gt;
 * 
 * @returns {Array} list
 */
response.prototype.model_ids = function(){
    var ret = [];
    if( this._data &amp;amp;&amp;amp; this._data[&#x27;meta&#x27;] &amp;amp;&amp;amp; this._data[&#x27;meta&#x27;][&#x27;model-ids&#x27;] &amp;amp;&amp;amp; 
	us.isArray(this._data[&#x27;meta&#x27;][&#x27;model-ids&#x27;]) ){
	ret = this._data[&#x27;meta&#x27;][&#x27;model-ids&#x27;];
    }
    return ret;
};

/**
 * Returns a hash of the model ids to models properties found in the
 * response.
 *
 * Sometimes not there, so check the return.
 *
 * WARNING: A work in progress, but this is intended as an eventual
 * replacement to model_ids.
 *
 * See Also: &amp;lt;model_ids&gt;
 * 
 * @returns {Object} hash
 */
response.prototype.models_meta = function(){
    var ret = {};
    if( this._data &amp;amp;&amp;amp; this._data[&#x27;meta&#x27;] &amp;amp;&amp;amp; this._data[&#x27;meta&#x27;][&#x27;models-meta&#x27;] &amp;amp;&amp;amp; 
	us.isObject(this._data[&#x27;meta&#x27;][&#x27;models-meta&#x27;]) ){
	ret = this._data[&#x27;meta&#x27;][&#x27;models-meta&#x27;];
    }
    return ret;
};

///
/// Exportable body.
///

module.exports = response;
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.3.2 on July 29, 2015.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>